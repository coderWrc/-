# 算法原理实现
#### 1. [堆的模拟实现](堆的模拟实现.md)   
#### 2. [排序算法](排序.md)
#### 3. [离散化](#离散化)



# 离散化
[top](#3-离散化)  
模板一：排序 + 去重 + 二分离散化之后的值
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int pos; // 标记去重之后的元素个数
int disc[N]; // 帮助离散化

// 二分 x 的位置
int find(int x)
{
	int l = 0, r = pos;
	while (l + 1 < r)
	{
		int mid = l + ((r - l) >> 1);
		if (disc[mid] < x) l = mid;
		else r = mid;
	}
	return r;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		disc[++pos] = a[i];
	}

	// 离散化
	sort(disc + 1, disc + 1 + pos); // 排序
	pos = unique(disc + 1, disc + 1 + pos) - (disc + 1); // 去重

	for (int i = 1; i <= n; i++)
	{
		cout << a[i] << "离散化之后：" << find(a[i]) << endl;
	}

	return 0;
}
```
