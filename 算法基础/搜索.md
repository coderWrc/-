# 搜索

#### 1. 深度优先搜索 - DFS
   1. 递归型枚举与回溯剪枝初识
       * [枚举子集（递归实现指数型枚举）](#枚举子集递归实现指数型枚举)
       * [组合型枚举](#组合型枚举)
       * [枚举排列（递归实现排列型枚举）](#枚举排列递归实现排列型枚举)


# [枚举子集（递归实现指数型枚举）](https://www.luogu.com.cn/problem/B3622)  
[top](#1-深度优先搜索---dfs)
```
#include <iostream>

using namespace std;

int n;
string path;

void dfs(int pos)
{
	if (pos > n)
	{
		cout << path << endl;
		return;
	}
	path += 'N';
	dfs(pos + 1);
	path.pop_back();
	path += 'Y';
	dfs(pos + 1);
	path.pop_back();
}

int main()
{
	cin >> n;
	dfs(1);

	return 0;
}
```
# [组合型枚举](https://www.luogu.com.cn/problem/P10448)
[top](#1-深度优先搜索---dfs)
```
#include <iostream>
#include <vector>

using namespace std;

int n, m;
vector<int> path;

void dfs(int begin)
{
	if (path.size() == m)
	{
		for (auto x : path)
		{
			cout << x << ' ';
		}
		cout << endl;
		return;
	}
	for (int i = begin; i <= n; i++)
	{
		path.push_back(i);
		dfs(i + 1);
		path.pop_back();
	}
}

int main()
{
	cin >> n >> m;
	dfs(1);

	return 0;
}
```
# [枚举排列（递归实现排列型枚举）](https://www.luogu.com.cn/problem/B3623)
[top](#1-深度优先搜索---dfs)
```
#include <iostream>
#include <vector>

using namespace std;

int n, k;
vector<int> path;
bool st[11]; // 记录哪些学生已经被选过了

void dfs()
{
	if (path.size() == k)
	{
		for (int x : path) cout << x << ' ';
		cout << endl;
		return;
	}
	for (int i = 1; i <= n; i++)
	{
		if (st[i]) continue; // 如果已经选过了，就跳过
		st[i] = true; // 选他
		path.push_back(i);
		dfs();
		st[i] = false;
		path.pop_back();
	}
}

int main()
{
	cin >> n >> k;
	dfs();

	return 0;
}
```
