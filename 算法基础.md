# 算法基础

1. 模拟
   * [多项式输出](#多项式输出)
   * [蛇形方阵](#蛇形方阵)
   * [字符串的展开](#字符串的展开)
2. 高精度
   * [A+B Problem(高精)](#ab-problem高精)
   * [高精度减法](#高精度减法)
   * [A*B Problem](#ab-problem)
   * [A/B Problem](#ab-problem-1)
3. 枚举
   * [铺地毯](#铺地毯)
   * [回文日期](#回文日期)
  
>位运算 排序 哈希集合 数学  
[只出现一次的数字](https://leetcode.cn/problems/single-number/description/)  
[丢失的数字](https://leetcode.cn/problems/missing-number/description/)  
[消失的数字](https://leetcode.cn/problems/missing-number-lcci/description/)  
   
>相向双指针  
[两数之和 || - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)  
[三数之和](LeetCode%20题解/LeetCode%2015.三数之和.md)  
   
>滑动窗口  
[长度最小的子数组](LeetCode%20题解/LeetCode%20209.长度最小的子数组.md)  
[乘积小于k的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)  
[无重复字符的最长子串](LeetCode%20题解/LeetCode%203.无重复字符的最长子串.md)  
  
>二分算法  
[在排序数组中查找元素的第一个和最后一个位置](LeetCode%20题解/LeetCode%2034.在排序数组中查找元素的第一个和最后一个位置.md)  
[正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/)  
[咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)  
[统计公平数对的数目](LeetCode%20题解/LeetCode%202563.统计公平数对的数目.md)   
[H 指数 ||](LeetCode%20题解/LeetCode%20275.H%20指数%20II.md)  
[爱吃香蕉的珂珂](LeetCode%20题解/LeetCode%20875.爱吃香蕉的珂珂.md)  
[完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/description/)  
[最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/description/)  
[最小化数组中的最大值](LeetCode%20题解/LeetCode%202439.最小化数组中的最大值.md)  
[礼盒的最大甜蜜度](LeetCode%20题解/LeetCode%202517.礼盒的最大甜蜜度.md)  
[每个小孩最多能分到多少糖果](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/description/)  
[两个数组间的距离值](LeetCode%20题解/LeetCode%201385.两个数组间的距离值.md)   
[使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/)  

## [多项式输出](https://www.luogu.com.cn/problem/P1067)  
[top](#算法基础)  
```
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
	int n; cin >> n;
	for (int i = n; i >= 0; i--)
	{
		int a; cin >> a;

		if (a == 0) continue;

		if (a < 0) cout << '-';
		else if (i != n) cout << '+';

		if (abs(a) != 1 || (i == 0)) cout << abs(a);

		if (i == 0) continue;
		else if (i == 1) cout << 'x';
		else cout << "x^" << i;
	}

	return 0;
}
```

## [蛇形方阵](https://www.luogu.com.cn/problem/P5731)  
[top](#算法基础)  
```
#include <iostream>

using namespace std;

const int N = 15;

int dx[] = { 0, 1, 0, -1 };
int dy[] = { 1, 0, -1, 0 };

int arr[N][N];

int main()
{
	int n; cin >> n;
	int x = 1, y = 1;
	int pos = 0;

	for (int i = 1; i <= n * n; i++)
	{
		arr[x][y] = i;
		int a = x + dx[pos], b = y + dy[pos];
		if (a < 1 || a > n || b < 1 || b > n || arr[a][b])
		{
			pos = (pos + 1) % 4;
			a = x + dx[pos], b = y + dy[pos];
		}
		x = a, y = b;
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			printf("%3d", arr[i][j]);
		}
		puts("");
	}

	return 0;
}
```

## [字符串的展开](https://www.luogu.com.cn/problem/P1098)  
[top](#算法基础)  
```
#include <iostream>
#include <cctype>
#include <algorithm>

using namespace std;

int p1, p2, p3, n;
string s;
string ret;

void add(char left, char right)
{
	string t;

	// 遍历中间字符
	for (char ch = left + 1; ch < right; ch++)
	{
		char tmp = ch;
		// 处理p1
		if (p1 == 2 && islower(tmp)) tmp -= 32;
		else if (p1 == 3) tmp = '*';

		// 处理p2
		for (int i = 0; i < p2; i++)
		{
			t += tmp;
		}
	}

	// 处理p3
	if (p3 == 2) reverse(t.begin(), t.end());

	ret += t;
}

int main()
{
	cin >> p1 >> p2 >> p3 >> s;
	n = s.size();

	for (int i = 0; i < n; i++)\
	{
		char ch = s[i];
		if (s[i] != '-' || i == 0 || i == n - 1) ret += ch;
		else
		{
			char left = s[i - 1], right = s[i + 1];
			// 判断是否展开
			if (isdigit(left) && isdigit(right) && left < right ||
				islower(left) && islower(right) && left < right)
			{
				// 展开
				add(left, right);
			}
			else
			{
				ret += ch;
			}
		}
	}
	cout << ret << endl;

	return 0;
}
```

## [A+B Problem(高精)](https://www.luogu.com.cn/problem/P1601)  
[top](#算法基础)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

void add(int c[], int a[], int b[])
{
	for (int i = 0; i < lc; i++)
	{
		c[i] += a[i] + b[i];
		c[i + 1] = c[i] / 10;
		c[i] %= 10;
	}
	if (c[lc]) lc++;
}

int main()
{
	string x, y; cin >> x >> y;

	la = x.size(); lb = y.size(); lc = max(la, lb);
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	add(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [高精度减法](https://www.luogu.com.cn/problem/P2142)
[top](#算法基础)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

bool cmp(string& x, string& y)
{
	if (x.size() != y.size()) return x.size() < y.size();
	return x < y;
}

void sub(int c[], int a[], int b[])
{
	for (int i = 0; i < lc; i++)
	{
		c[i] += a[i] - b[i];
		if (c[i] < 0)
		{
			c[i] += 10;
			c[i + 1] -= 1;
		}
	}
	while (lc > 1 && c[lc - 1] == 0) lc--;
}

int main()
{
	string x, y; cin >> x >> y;
	
	if (cmp(x, y))
	{
		swap(x, y);
		cout << '-';
	}

	la = x.size(); lb = y.size(); lc = max(la, lb);
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	sub(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [A*B Problem](https://www.luogu.com.cn/problem/P1303)
[top](#算法基础)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

void mul(int c[], int a[], int b[])
{
	for (int i = 0; i < la; i++)
	{
		for (int j = 0; j < lb; j++)
		{
			c[i + j] += a[i] * b[j];
		}
	}
	for (int i = 0; i < lc; i++)
	{
		c[i + 1] += c[i] / 10;
		c[i] %= 10;
	}
	while (lc > 1 && c[lc - 1] == 0) lc--;
}

int main()
{
	string x, y; cin >> x >> y;

	la = x.size(); lb = y.size(); lc = la + lb;
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	mul(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [A/B Problem](https://www.luogu.com.cn/problem/P1480)
[top](#算法基础)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10; 

typedef long long LL;

int a[N], b, c[N];
int la, lc;

void div(int c[], int a[], int b)
{
	LL t = 0;
	for (int i = la - 1; i >= 0; i--)
	{
		t = t * 10 + a[i];
		c[i] = t / b;
		t %= b;
	}
	while (lc > 1 && c[lc - 1] == 0) lc--;
}

int main()
{
	string x; cin >> x >> b;

	lc = la = x.size(); 
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';

	div(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [铺地毯](https://www.luogu.com.cn/problem/P1003)
[top](#算法基础)
```
#include <iostream>

using namespace std;

const int N = 1e4 + 10;

int n;
int a[N], b[N], g[N], k[N];
int x, y;

int find()
{
	for (int i = n; i >= 1; i--)
	{
		if (a[i] <= x && b[i] <= y && x <= a[i] + g[i] && y <= b[i] + k[i])
			return i;
	}
	return -1;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
	cin >> x >> y;
	cout << find() << endl;

	return 0;
}
```
# [回文日期](https://www.luogu.com.cn/problem/P2010)
[top](#算法基础)
>1. 法一：枚举 x ~ y 之间的所有数，判断是否是回文，如果是，再拆分成年月日，判断日期是否合法即可

```
```
>2. 法二：仅枚举年份，构成回文形式的日月，判断日期是否合法即可

```
```
>3. 法三：枚举所有日和月的组合，拼成回文日期，判断日期是否合法即可

```
#include <iostream>

using namespace std;

int x, y;
// 9220 是闰年，所以可以直接把二月设成 29 天
int day[] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

int main()
{
	cin >> x >> y;
	int ret = 0; 
	for (int i = 1; i <= 12; i++)
	{
		for (int j = 1; j <= day[i]; j++)
		{
			int k = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10;
			int num = k * 10000 + i * 100 + j;
			if (num >= x && num <= y) ret++;
		}
	}
	cout << ret << endl;

	return 0;
}
```
