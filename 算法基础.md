# 算法基础

1. 模拟
   * [多项式输出](#多项式输出)
   * [蛇形方阵](#蛇形方阵)
   * [字符串的展开](#字符串的展开)
2. 高精度
   * [A+B Problem(高精)](#ab-problem高精)
  
>位运算 排序 哈希集合 数学  
[只出现一次的数字](https://leetcode.cn/problems/single-number/description/)  
[丢失的数字](https://leetcode.cn/problems/missing-number/description/)  
[消失的数字](https://leetcode.cn/problems/missing-number-lcci/description/)  
   
>相向双指针  
[两数之和 || - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)  
[三数之和](LeetCode%20题解/LeetCode%2015.三数之和.md)  
   
>滑动窗口  
[长度最小的子数组](LeetCode%20题解/LeetCode%20209.长度最小的子数组.md)  
[乘积小于k的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)  
[无重复字符的最长子串](LeetCode%20题解/LeetCode%203.无重复字符的最长子串.md)  
  
>二分算法  
[在排序数组中查找元素的第一个和最后一个位置](LeetCode%20题解/LeetCode%2034.在排序数组中查找元素的第一个和最后一个位置.md)  
[正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/)  
[咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)  
[统计公平数对的数目](LeetCode%20题解/LeetCode%202563.统计公平数对的数目.md)   
[H 指数 ||](LeetCode%20题解/LeetCode%20275.H%20指数%20II.md)  
[爱吃香蕉的珂珂](LeetCode%20题解/LeetCode%20875.爱吃香蕉的珂珂.md)  
[完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/description/)  
[最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/description/)  
[最小化数组中的最大值](LeetCode%20题解/LeetCode%202439.最小化数组中的最大值.md)  
[礼盒的最大甜蜜度](LeetCode%20题解/LeetCode%202517.礼盒的最大甜蜜度.md)  
[每个小孩最多能分到多少糖果](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/description/)  
[两个数组间的距离值](LeetCode%20题解/LeetCode%201385.两个数组间的距离值.md)   
[使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/)  

## [多项式输出](https://www.luogu.com.cn/problem/P1067)  
[top](#算法基础)  
```
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
	int n; cin >> n;
	for (int i = n; i >= 0; i--)
	{
		int a; cin >> a;

		if (a == 0) continue;

		if (a < 0) cout << '-';
		else if (i != n) cout << '+';

		if (abs(a) != 1 || (i == 0)) cout << abs(a);

		if (i == 0) continue;
		else if (i == 1) cout << 'x';
		else cout << "x^" << i;
	}

	return 0;
}
```

## [蛇形方阵](https://www.luogu.com.cn/problem/P5731)  
[top](#算法基础)  
```
#include <iostream>

using namespace std;

const int N = 15;

int dx[] = { 0, 1, 0, -1 };
int dy[] = { 1, 0, -1, 0 };

int arr[N][N];

int main()
{
	int n; cin >> n;
	int x = 1, y = 1;
	int pos = 0;

	for (int i = 1; i <= n * n; i++)
	{
		arr[x][y] = i;
		int a = x + dx[pos], b = y + dy[pos];
		if (a < 1 || a > n || b < 1 || b > n || arr[a][b])
		{
			pos = (pos + 1) % 4;
			a = x + dx[pos], b = y + dy[pos];
		}
		x = a, y = b;
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			printf("%3d", arr[i][j]);
		}
		puts("");
	}

	return 0;
}
```

## [字符串的展开](https://www.luogu.com.cn/problem/P1098)  
[top](#算法基础)  
```
#include <iostream>
#include <cctype>
#include <algorithm>

using namespace std;

int p1, p2, p3, n;
string s;
string ret;

void add(char left, char right)
{
	string t;

	// 遍历中间字符
	for (char ch = left + 1; ch < right; ch++)
	{
		char tmp = ch;
		// 处理p1
		if (p1 == 2 && islower(tmp)) tmp -= 32;
		else if (p1 == 3) tmp = '*';

		// 处理p2
		for (int i = 0; i < p2; i++)
		{
			t += tmp;
		}
	}

	// 处理p3
	if (p3 == 2) reverse(t.begin(), t.end());

	ret += t;
}

int main()
{
	cin >> p1 >> p2 >> p3 >> s;
	n = s.size();

	for (int i = 0; i < n; i++)\
	{
		char ch = s[i];
		if (s[i] != '-' || i == 0 || i == n - 1) ret += ch;
		else
		{
			char left = s[i - 1], right = s[i + 1];
			// 判断是否展开
			if (isdigit(left) && isdigit(right) && left < right ||
				islower(left) && islower(right) && left < right)
			{
				// 展开
				add(left, right);
			}
			else
			{
				ret += ch;
			}
		}
	}
	cout << ret << endl;

	return 0;
}
```

## [A+B Problem(高精)](https://www.luogu.com.cn/problem/P1601)  
[top](#算法基础)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

void add(int c[], int a[], int b[])
{
	for (int i = 0; i < lc; i++)
	{
		c[i] += a[i] + b[i];
		c[i + 1] = c[i] / 10;
		c[i] %= 10;
	}
	if (c[lc]) lc++;
}

int main()
{
	string x, y; cin >> x >> y;

	la = x.size(); lb = y.size(); lc = max(la, lb);
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	add(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
